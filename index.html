<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secret Word Imposter Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for a dark, space-themed look */
        body {
            background-color: #1a1a2e; /* Dark purple/blue */
            color: #ffffff;
        }
        .card {
            background-color: #2c2c54; /* Slightly lighter card background */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
        }
        .btn-primary {
            transition: all 0.2s;
            background-color: #ff6b6b; /* Red accent */
            color: #1a1a2e;
            font-weight: bold;
            box-shadow: 0 4px #e55039;
        }
        .btn-primary:hover {
            background-color: #ff8585;
            box-shadow: 0 2px #e55039;
            transform: translateY(2px);
        }
        .btn-secondary {
            transition: all 0.2s;
            background-color: #48dbfb; /* Blue accent */
            color: #1a1a2e;
            font-weight: bold;
            box-shadow: 0 4px #1e90ff;
        }
        .btn-secondary:hover {
            background-color: #6aefff;
            box-shadow: 0 2px #1e90ff;
            transform: translateY(2px);
        }
        /* Mobile optimization for buttons and inputs */
        input[type="text"], .btn {
            height: 52px;
            font-size: 1.1rem;
        }
        .imposter-role { background-color: #e53e3e; }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen font-sans">
    
    <div id="app" class="w-full max-w-lg">
        
        <!-- Status Display -->
        <div id="status-message" class="text-center p-3 mb-4 rounded-lg text-sm bg-gray-700 text-gray-300">
            STATUS: Initializing Firebase...
        </div>

        <!-- Main Content Area -->
        <div id="content" class="card p-6 rounded-xl space-y-6">
            <h1 class="text-3xl font-extrabold text-center text-[#ff6b6b]">
                <svg class="inline-block w-8 h-8 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                The Secret Word Game
            </h1>

            <!-- Lobby Creation/Joining View -->
            <div id="lobby-view" class="space-y-4">
                <button id="create-lobby-btn" class="w-full btn-primary btn rounded-lg">
                    Create New Lobby
                </button>

                <div class="flex items-center space-x-2 text-gray-400">
                    <hr class="flex-grow border-gray-600">
                    <span class="text-sm">OR JOIN</span>
                    <hr class="flex-grow border-gray-600">
                </div>

                <div class="flex space-x-2">
                    <input type="text" id="join-lobby-id" placeholder="Enter Lobby ID" class="flex-grow p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 focus:ring-[#48dbfb] outline-none">
                    <button id="join-lobby-btn" class="btn-secondary btn px-6 rounded-lg">
                        Join
                    </button>
                </div>
            </div>

            <!-- Game Lobby View -->
            <div id="game-lobby-view" class="hidden space-y-4">
                <h2 class="text-2xl font-bold text-center">Lobby: <span id="current-lobby-id" class="text-[#48dbfb]"></span></h2>
                <p class="text-sm text-gray-400 text-center">Share this ID with friends!</p>
                <div class="text-sm text-center text-gray-500">
                    Your Player ID: <span id="current-user-id" class="break-all font-mono text-xs"></span>
                </div>
                
                <!-- Player Count Display - Now more prominent -->
                <div class="text-2xl font-extrabold text-center mt-4 p-2 bg-gray-700 rounded-lg border-b-4 border-[#ff6b6b]">
                     Active Players: <span id="player-count" class="text-[#48dbfb]">0</span>
                </div>

                <h3 class="text-lg font-semibold mt-4">Players in Lobby:</h3>
                <ul id="players-list" class="space-y-2 p-3 rounded-lg bg-gray-700 h-40 overflow-y-auto">
                    <!-- Player names go here -->
                </ul>

                <button id="start-game-btn" class="w-full btn-primary btn rounded-lg mt-4 disabled:opacity-50" disabled>
                    Start Game (Need 3+ Players)
                </button>
                <button id="leave-lobby-btn" class="w-full btn-secondary btn rounded-lg mt-2">
                    Leave Lobby
                </button>
            </div>

            <!-- Active Game View (Word Deduction) -->
            <div id="game-active-view" class="hidden space-y-6">
                <div id="role-display" class="text-center p-4 rounded-xl font-bold text-xl transition-all duration-500 bg-gray-800">
                    Your Role: <span id="player-role-text" class="text-yellow-400">Loading...</span>
                </div>
                
                <div class="p-4 rounded-xl bg-gray-800 border-2 border-[#48dbfb]">
                    <p class="text-lg font-bold text-center">SECRET WORD:</p>
                    <p id="secret-word-display" class="text-4xl font-extrabold text-center text-[#ff6b6b] mt-1">???</p>
                </div>

                <div id="game-info" class="p-3 rounded-lg bg-gray-700 flex justify-between items-center">
                    <div class="space-y-1">
                        <p class="text-lg font-bold">Round <span id="current-round-number">1</span> / <span id="total-rounds-number">4</span></p>
                        <p class="text-sm text-gray-400 font-bold" id="game-phase-label">Status: Active</p>
                    </div>
                    <div class="text-right">
                         <p class="text-xl font-extrabold text-[#48dbfb]" id="round-timer">00:00</p>
                         <button id="call-vote-btn" class="text-sm text-yellow-400 hover:text-yellow-300 disabled:opacity-50" disabled>Call Emergency Vote</button>
                    </div>
                </div>
                
                <!-- Description Input and Submission -->
                <div id="description-area" class="space-y-2">
                    <label for="description-input" class="block font-semibold">Your Description for this Round:</label>
                    <div class="flex space-x-2">
                        <input type="text" id="description-input" maxlength="50" placeholder="Describe the word..." class="flex-grow p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 focus:ring-[#48dbfb] outline-none disabled:opacity-50">
                        <button id="submit-description-btn" class="btn-primary btn px-6 rounded-lg disabled:opacity-50">Submit</button>
                    </div>
                    <p id="submission-status" class="text-sm text-green-400 hidden">Submitted!</p>
                </div>

                <!-- Previous Descriptions Display -->
                <h3 class="text-lg font-semibold mt-4">Round Descriptions:</h3>
                <ul id="descriptions-list" class="space-y-3 p-3 rounded-lg bg-gray-700 max-h-60 overflow-y-auto">
                    <li class="text-gray-400 text-center">Descriptions will appear here after submission.</li>
                </ul>
                
                <button id="leave-game-btn" class="w-full btn-secondary btn rounded-lg mt-4">
                    Quit Game
                </button>
            </div>
            
            <!-- Voting View -->
            <div id="voting-view" class="hidden space-y-6">
                <h2 class="text-3xl font-bold text-center text-[#ff6b6b]">VOTING PHASE!</h2>
                <p class="text-center text-lg text-gray-300" id="voting-reason">Time is up. Who is the Imposter?</p>
                
                <h3 class="text-xl font-semibold mt-4">Vote to eject:</h3>
                <ul id="voting-list" class="space-y-2 p-3 rounded-lg bg-gray-700 max-h-60 overflow-y-auto">
                    <!-- Voting buttons go here -->
                </ul>
                
                <button id="skip-vote-btn" class="w-full bg-gray-500 hover:bg-gray-400 text-white font-bold py-3 px-4 rounded-lg">
                    Skip Vote
                </button>
            </div>

            <!-- Game Over View -->
            <div id="game-over-view" class="hidden space-y-6">
                <h2 class="text-4xl font-extrabold text-center" id="win-message"></h2>
                <p class="text-center text-xl text-gray-300">The Secret Word was: <span id="final-secret-word" class="text-yellow-400 font-bold"></span></p>
                <p class="text-center text-xl text-gray-300">Roles were:</p>
                <ul id="final-roles-list" class="space-y-2 p-3 rounded-lg bg-gray-700">
                    <!-- Final roles displayed here -->
                </ul>
                <button id="return-to-lobby-btn" class="w-full btn-secondary btn rounded-lg mt-4">
                    Return to Lobby
                </button>
            </div>

        </div>
    </div>
    
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, deleteDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIGURATION SETUP (ROBUST AGAINST EXTERNAL DEPLOYMENT) ---
        
        const localFirebaseConfig = {
            apiKey: "AIzaSyCWEJOsUXTjdkYPUF_Iz6j5siieTJw5Rs0",
            authDomain: "impostergame-dev.firebaseapp.com",
            projectId: "impostergame-dev",
            storageBucket: "impostergame-dev.firebasestorage.app",
            messagingSenderId: "619697208061",
            appId: "1:619697208061:web:0a62ff8e6a9a701140dc94",
            measurementId: "G-C1HWQ86HV3"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : localFirebaseConfig.projectId;
        let firebaseConfig;
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
             try {
                firebaseConfig = JSON.parse(__firebase_config);
             } catch (e) {
                console.error("Failed to parse __firebase_config. Falling back to local config.", e);
                firebaseConfig = localFirebaseConfig;
             }
        } else {
             firebaseConfig = localFirebaseConfig;
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        setLogLevel('Debug');
        let app, db, auth;
        let userId = null;
        let currentLobbyId = null;
        let unsubscribeLobby = null;
        let localPlayerRole = null;
        let hostTimerInterval = null; // Timer for the host to manage rounds

        // --- GAME CONSTANTS ---
        const MAX_PLAYERS = 100; 
        const MIN_PLAYERS_TO_START = 3; 
        const IMPOSTER_COUNT = 1; 
        const ROUND_DURATION_SECONDS = 120; // 2 minutes
        const COOLDOWN_DURATION_SECONDS = 5; // 5 seconds
        const TOTAL_ROUNDS = 4;
        
        // Simple word list for the crewmates
        const WORD_LIST = ["SPACESHIP", "GALAXY", "PIZZA", "OCEAN", "MOUNTAIN", "KEYBOARD", "BOOK", "FARMER"];

        // --- UI ELEMENT REFERENCES ---

        const statusEl = document.getElementById('status-message');
        const lobbyViewEl = document.getElementById('lobby-view');
        const gameLobbyViewEl = document.getElementById('game-lobby-view');
        const gameActiveViewEl = document.getElementById('game-active-view');
        const votingViewEl = document.getElementById('voting-view');
        const gameOverViewEl = document.getElementById('game-over-view');

        const currentUserIdEl = document.getElementById('current-user-id');
        const playersListEl = document.getElementById('players-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        
        const playerCountEl = document.getElementById('player-count'); // Reference for the count
        
        const playerRoleTextEl = document.getElementById('player-role-text');
        const secretWordDisplayEl = document.getElementById('secret-word-display');
        const currentRoundNumberEl = document.getElementById('current-round-number');
        const totalRoundsNumberEl = document.getElementById('total-rounds-number');
        const gamePhaseLabelEl = document.getElementById('game-phase-label');
        const roundTimerEl = document.getElementById('round-timer');
        const callVoteBtn = document.getElementById('call-vote-btn');
        const descriptionInputEl = document.getElementById('description-input');
        const submitDescriptionBtn = document.getElementById('submit-description-btn');
        const submissionStatusEl = document.getElementById('submission-status');
        const descriptionsListEl = document.getElementById('descriptions-list');

        const votingReasonEl = document.getElementById('voting-reason');
        const votingListEl = document.getElementById('voting-list');
        const skipVoteBtn = document.getElementById('skip-vote-btn');
        
        const winMessageEl = document.getElementById('win-message');
        const finalSecretWordEl = document.getElementById('final-secret-word');
        const finalRolesListEl = document.getElementById('final-roles-list');

        // --- UTILITIES ---

        function updateStatus(message) {
            statusEl.textContent = `STATUS: ${message}`;
        }
        
        function displayErrorMessage(message) {
             statusEl.textContent = `ERROR: ${message}`;
             statusEl.classList.add('bg-red-700', 'text-red-200');
             setTimeout(() => {
                 statusEl.classList.remove('bg-red-700', 'text-red-200');
                 statusEl.textContent = '';
             }, 5000);
        }

        function resetViews() {
            lobbyViewEl.classList.remove('hidden');
            gameLobbyViewEl.classList.add('hidden');
            gameActiveViewEl.classList.add('hidden');
            votingViewEl.classList.add('hidden');
            gameOverViewEl.classList.add('hidden');
        }

        function getLobbyDocRef(id) {
            return doc(db, `artifacts/${appId}/public/data/lobbies`, id);
        }

        function generateLobbyId() {
            return Math.random().toString(36).substring(2, 6).toUpperCase();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- GAME FLOW CORE FUNCTIONS ---
        
        /**
         * Host-only function to advance the game state based on the timer.
         * Runs every second while the game is active.
         */
        async function runHostTimer(lobbyId) {
            if (hostTimerInterval) clearInterval(hostTimerInterval);
            
            hostTimerInterval = setInterval(async () => {
                const lobbyRef = getLobbyDocRef(lobbyId);
                let docSnap = null;
                try {
                    docSnap = await getDoc(lobbyRef);
                } catch (e) {
                    console.error("Host timer failed to fetch doc:", e);
                    clearInterval(hostTimerInterval);
                    return;
                }

                if (!docSnap.exists() || docSnap.data().status !== 'in_game') {
                    clearInterval(hostTimerInterval);
                    return;
                }
                
                const data = docSnap.data();
                const now = Date.now();
                const timeRemaining = data.roundEndTime ? data.roundEndTime - now : 0;
                
                if (timeRemaining <= 0) {
                    // Time is up, advance state
                    let updateData = {};
                    
                    if (data.gameState === 'round_active') {
                        // Move to Cooldown or Voting
                        if (data.currentRound < TOTAL_ROUNDS) {
                            // Start Cooldown
                            const nextRound = data.currentRound + 1;
                            updateData = {
                                gameState: 'cooldown',
                                roundEndTime: now + COOLDOWN_DURATION_SECONDS * 1000,
                                // Reset descriptions for the next round
                                descriptions: {} 
                            };
                            updateStatus(`Host: Round ${data.currentRound} ended. ${COOLDOWN_DURATION_SECONDS}s cooldown...`);
                        } else {
                            // Move to Final Voting
                            updateData = {
                                gameState: 'voting',
                                roundEndTime: null,
                                votingReason: 'Final vote: All description rounds complete.'
                            };
                            updateStatus("Host: Final round ended. Starting vote.");
                        }
                        
                    } else if (data.gameState === 'cooldown') {
                        // Move to Next Round Active
                        const nextRound = data.currentRound + 1;
                        if (nextRound <= TOTAL_ROUNDS) {
                             updateData = {
                                gameState: 'round_active',
                                currentRound: nextRound,
                                roundEndTime: now + ROUND_DURATION_SECONDS * 1000,
                                descriptions: {} // Clear descriptions again, just in case
                            };
                            updateStatus(`Host: Starting Round ${nextRound}`);
                        } else {
                            // Should have moved to voting in the previous state check, but handle fallback
                             updateData = {
                                gameState: 'voting',
                                roundEndTime: null,
                                votingReason: 'Final vote: All description rounds complete.'
                            };
                        }
                    } else {
                        // Game state is 'voting' or 'finished', stop host timer
                        clearInterval(hostTimerInterval);
                        return;
                    }

                    if (Object.keys(updateData).length > 0) {
                        await updateDoc(lobbyRef, updateData);
                    }
                }
            }, 1000);
        }

        async function startGameLogic(players, lobbyId) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            
            // 1. Assign Roles
            const playerIds = players.map(p => p.id);
            shuffleArray(playerIds);
            const imposterId = playerIds[0];

            const playerRoles = players.map(player => ({
                ...player,
                role: player.id === imposterId ? 'imposter' : 'crewmate',
                isEliminated: false,
                hasVoted: false,
                vote: null,
                name: player.name || `Player_${player.id.substring(0, 4)}` // Ensure names are set
            }));
            
            // 2. Select Secret Word
            shuffleArray(WORD_LIST);
            const secretWord = WORD_LIST[0];

            // 3. Set Initial Game State
            const now = Date.now();
            const gameData = {
                id: lobbyId,
                status: 'in_game',
                gameState: 'round_active',
                secretWord: secretWord,
                roles: playerRoles,
                hostId: userId,
                currentRound: 1,
                totalRounds: TOTAL_ROUNDS,
                roundEndTime: now + ROUND_DURATION_SECONDS * 1000,
                descriptions: {}, // { playerId: description } for the current round
                votes: {}, // { voterId: votedPlayerId } for the voting phase
                createdAt: new Date().toISOString()
            };
            
            try {
                await updateDoc(lobbyRef, gameData);
                updateStatus("Game started successfully!");
            } catch (error) {
                displayErrorMessage(`Failed to start game: ${error.message}`);
                console.error("Game Start Error:", error);
            }
        }

        // --- GAME ACTIONS ---

        async function submitDescription(description, lobbyId) {
            if (!description.trim()) {
                displayErrorMessage("Description cannot be empty.");
                return;
            }
            const lobbyRef = getLobbyDocRef(lobbyId);
            const docSnap = await getDoc(lobbyRef);
            const data = docSnap.data();

            if (data.roles.find(p => p.id === userId && p.isEliminated)) {
                displayErrorMessage("You are eliminated and cannot submit descriptions.");
                return;
            }
            
            // Do not allow submission if not in active round
            if (data.gameState !== 'round_active') {
                displayErrorMessage("Cannot submit description outside of an active round.");
                return;
            }

            try {
                // Update the descriptions map with the player's submission
                const newDescriptions = { 
                    ...data.descriptions, 
                    [userId]: description.trim() 
                };
                
                await updateDoc(lobbyRef, { descriptions: newDescriptions });
                submissionStatusEl.textContent = 'Submitted!';
                submissionStatusEl.classList.remove('hidden');
                submitDescriptionBtn.disabled = true;
                descriptionInputEl.disabled = true;
            } catch (error) {
                displayErrorMessage(`Submission error: ${error.message}`);
                console.error("Description Submission Error:", error);
            }
        }
        
        async function submitVote(votedPlayerId, lobbyId) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            const docSnap = await getDoc(lobbyRef);
            const data = docSnap.data();

            const localPlayer = data.roles.find(p => p.id === userId);
            if (!localPlayer || localPlayer.hasVoted || localPlayer.isEliminated) return;

            try {
                // Update the local player's vote state
                const updatedRoles = data.roles.map(p => {
                    if (p.id === userId) {
                        return { ...p, hasVoted: true, vote: votedPlayerId };
                    }
                    return p;
                });

                // Calculate the number of votes cast *after* this one
                const newVoteCount = updatedRoles.filter(p => p.hasVoted).length;
                
                await updateDoc(lobbyRef, {
                    roles: updatedRoles,
                    voteCount: newVoteCount // This triggers the host to check results
                });
                updateStatus(`Voted. Waiting for others.`);

            } catch (error) {
                displayErrorMessage(`Voting error: ${error.message}`);
            }
        }

        async function checkVoteResult(data) {
            const activePlayers = data.roles.filter(p => !p.isEliminated);
            const totalVotesExpected = activePlayers.length;
            const votesCast = data.roles.filter(p => p.hasVoted).length;

            if (votesCast < totalVotesExpected) return; // Wait for all votes

            // Tally votes
            const tallies = {};
            data.roles.forEach(p => {
                if (p.vote) { // Null vote is skip, not tallied
                    tallies[p.vote] = (tallies[p.vote] || 0) + 1;
                }
            });

            // Find the maximum number of votes
            let maxVotes = 0;
            let ejectedId = null;
            let tied = false;

            for (const [id, count] of Object.entries(tallies)) {
                if (count > maxVotes) {
                    maxVotes = count;
                    ejectedId = id;
                    tied = false;
                } else if (count === maxVotes && maxVotes > 0) {
                    tied = true;
                }
            }
            
            let ejectedPlayer = null;
            let updateData = {}; 

            if (ejectedId && !tied) {
                // Eject the player with the most votes (no tie)
                ejectedPlayer = data.roles.find(p => p.id === ejectedId);
                const updatedRoles = data.roles.map(p => {
                    if (p.id === ejectedId) {
                        return { ...p, isEliminated: true };
                    }
                    return p;
                });
                
                const imposterEjected = ejectedPlayer.role === 'imposter';

                updateData = {
                    roles: updatedRoles,
                    // Determine end state
                    status: imposterEjected ? 'finished' : 'in_game',
                    gameState: 'cooldown', // Always go to cooldown after a vote/ejection
                    winner: imposterEjected ? 'crewmate' : null,
                    // If continuing, set up the next round/cooldown
                    currentRound: data.currentRound, 
                    roundEndTime: imposterEjected ? null : Date.now() + COOLDOWN_DURATION_SECONDS * 1000, 
                };
                
            } else {
                // Tie or no votes cast (skip vote) - return to game
                updateData = {
                    gameState: 'cooldown', // Always move to cooldown after a skipped or tied vote
                    currentRound: data.currentRound, 
                    roundEndTime: Date.now() + COOLDOWN_DURATION_SECONDS * 1000,
                };
                updateStatus("Host: Vote resulted in a tie or skip. Moving to cooldown.");
            }
            
            // Reset voting state and apply elimination (if any)
            updateData.roles = updateData.roles || data.roles;
            updateData.roles = updateData.roles.map(p => ({
                ...p,
                hasVoted: false,
                vote: null,
            }));
            
            // Only host updates the doc after processing votes
            if (data.hostId === userId) {
                 await updateDoc(getLobbyDocRef(data.id), updateData);
            }
        }
        
        async function callEmergencyVote(lobbyId) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            try {
                const docSnap = await getDoc(lobbyRef);
                const data = docSnap.data();

                if (data.hostId !== userId) {
                    displayErrorMessage("Only the host can call an emergency vote.");
                    return;
                }

                if (data.gameState !== 'voting') {
                    await updateDoc(lobbyRef, {
                        gameState: 'voting',
                        votingReason: `Emergency Vote called by Host!`,
                        roundEndTime: null // Pause timer
                    });
                    updateStatus("Emergency Vote called!");
                }
            } catch (error) {
                displayErrorMessage(`Vote error: ${error.message}`);
            }
        }

        async function endGame(lobbyId, winner, roles) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            if (hostTimerInterval) clearInterval(hostTimerInterval);

            // Only host updates the final state
            if (roles.find(p => p.id === userId)?.role === 'imposter' || roles.find(p => p.id === userId)?.isHost || data.hostId === userId) {
                 await updateDoc(lobbyRef, {
                    status: 'finished',
                    gameState: 'finished',
                    winner: winner,
                    roles: roles 
                });
            }
        }


        // --- REAL-TIME LOBBY LISTENER (onSnapshot) ---
        
        function subscribeToLobby(lobbyId) {
            if (unsubscribeLobby) unsubscribeLobby();
            if (hostTimerInterval) clearInterval(hostTimerInterval); // Ensure timer is stopped before starting new listener

            const lobbyRef = getLobbyDocRef(lobbyId);
            
            unsubscribeLobby = onSnapshot(lobbyRef, (docSnap) => {
                if (docSnap.exists()) {
                    const lobbyData = docSnap.data();
                    
                    if (lobbyData.status === 'waiting') {
                        enterLobbyView(lobbyId);
                        renderLobbyDetails(lobbyData);
                    } else if (lobbyData.status === 'in_game') {
                        // Start or restart host timer if we are the host and game is active
                        if (lobbyData.hostId === userId && (lobbyData.gameState === 'round_active' || lobbyData.gameState === 'cooldown')) {
                             runHostTimer(lobbyId);
                        }
                        renderGameController(lobbyData);
                    } else if (lobbyData.status === 'finished') {
                        enterGameOverView(lobbyData);
                    }
                    
                } else {
                    if (currentLobbyId === lobbyId) {
                        displayErrorMessage("The lobby was closed or deleted.");
                        leaveLobby(); 
                    }
                }
            }, (error) => {
                console.error("Lobby Snapshot Error:", error);
                displayErrorMessage("Lost connection to the lobby.");
                leaveLobby();
            });
        }
        
        // --- RENDER CONTROLLERS ---

        function renderGameController(data) {
            const localPlayer = data.roles.find(p => p.id === userId);
            localPlayerRole = localPlayer ? localPlayer.role : null;
            
            // Check win condition on every update (Crewmates win if Imposter is eliminated, or Imposter wins if all rounds are over and they are safe)
            const imposterEliminated = data.roles.find(p => p.role === 'imposter' && p.isEliminated);
            const activeCrewmates = data.roles.filter(p => p.role === 'crewmate' && !p.isEliminated);

            if (imposterEliminated) {
                endGame(data.id, 'crewmate', data.roles);
                return;
            }
            
            // Imposter wins if there are not enough crewmates left
            if (activeCrewmates.length <= IMPOSTER_COUNT) {
                endGame(data.id, 'imposter', data.roles);
                return;
            }
            
            // Imposter wins if all rounds are over and they haven't been caught
            if (data.gameState === 'cooldown' && data.currentRound > TOTAL_ROUNDS) {
                 endGame(data.id, 'imposter', data.roles);
                 return;
            }

            if (data.gameState === 'voting') {
                gameActiveViewEl.classList.add('hidden');
                votingViewEl.classList.remove('hidden');
                renderVotingView(data);
                // Host checks vote result once all votes are in
                if (data.hostId === userId) {
                     checkVoteResult(data);
                }
            } else {
                votingViewEl.classList.add('hidden');
                gameActiveViewEl.classList.remove('hidden');
                renderActiveGameView(data);
            }
        }
        
        function renderLobbyDetails(lobbyData) {
            const players = lobbyData.players || [];
            playersListEl.innerHTML = '';
            
            // Update the prominent player count
            playerCountEl.textContent = players.length; 

            const isHost = lobbyData.hostId === userId;
            startGameBtn.disabled = !isHost || players.length < MIN_PLAYERS_TO_START;
            
            if (isHost) {
                startGameBtn.textContent = players.length < MIN_PLAYERS_TO_START 
                    ? `Need ${MIN_PLAYERS_TO_START - players.length} more players to start`
                    : 'START GAME';
            } else {
                startGameBtn.textContent = "Waiting for Host to Start...";
            }

            players.forEach(player => {
                const li = document.createElement('li');
                let name = player.name;
                if (player.id === userId) {
                    name += " (You)";
                }
                if (player.id === lobbyData.hostId) {
                    name += " ✨Host";
                }
                
                li.className = 'p-2 rounded-md bg-gray-600 flex justify-between items-center';
                li.textContent = name;
                playersListEl.appendChild(li);
            });
        }
        
        function renderActiveGameView(data) {
            const localPlayer = data.roles.find(p => p.id === userId);
            const isEliminated = localPlayer?.isEliminated || false;
            const isHost = data.hostId === userId;
            
            // 1. Role and Word Display
            playerRoleTextEl.textContent = localPlayerRole === 'imposter' ? 'IMPOSTER' : 'CREWMATE';
            playerRoleTextEl.classList.toggle('imposter-role', localPlayerRole === 'imposter');
            playerRoleTextEl.classList.toggle('text-yellow-400', localPlayerRole !== 'imposter');

            const wordToDisplay = localPlayerRole === 'crewmate' ? data.secretWord : '???';
            secretWordDisplayEl.textContent = wordToDisplay;

            // 2. Round Info
            currentRoundNumberEl.textContent = data.currentRound;
            totalRoundsNumberEl.textContent = data.totalRounds;
            gamePhaseLabelEl.textContent = data.gameState === 'cooldown' ? 'Status: COOLDOWN' : 'Status: ACTIVE';
            
            // 3. Timer
            const now = Date.now();
            const timeRemaining = data.roundEndTime ? Math.max(0, data.roundEndTime - now) : 0;
            const seconds = Math.floor(timeRemaining / 1000);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            roundTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            // 4. Submission Area
            const submitted = !!data.descriptions[userId];
            const isActive = data.gameState === 'round_active';
            
            descriptionInputEl.disabled = submitted || !isActive || isEliminated;
            submitDescriptionBtn.disabled = submitted || !isActive || isEliminated || !descriptionInputEl.value.trim();
            
            submissionStatusEl.classList.toggle('hidden', !submitted);
            submissionStatusEl.textContent = submitted ? 'Submitted!' : '';
            
            descriptionInputEl.oninput = () => {
                 submitDescriptionBtn.disabled = submitted || !isActive || isEliminated || !descriptionInputEl.value.trim();
            };

            // 5. Descriptions List
            descriptionsListEl.innerHTML = '';
            const playerNames = data.roles.reduce((acc, p) => { acc[p.id] = p.name; return acc; }, {});

            // Sort descriptions by player name for consistency
            const submittedDescriptions = Object.entries(data.descriptions).map(([playerId, description]) => ({
                name: playerNames[playerId] || playerId.substring(0, 4),
                description: description,
                isEliminated: data.roles.find(p => p.id === playerId)?.isEliminated
            })).sort((a, b) => a.name.localeCompare(b.name));
            
            if (submittedDescriptions.length === 0) {
                 descriptionsListEl.innerHTML = '<li class="text-gray-400 text-center">Descriptions will appear here after submission.</li>';
            } else {
                submittedDescriptions.forEach(desc => {
                    const li = document.createElement('li');
                    li.className = `p-3 rounded-lg bg-gray-600 border-l-4 ${desc.isEliminated ? 'border-gray-500 text-gray-500 line-through' : 'border-[#48dbfb]'}`;
                    li.innerHTML = `
                        <span class="font-bold">${desc.name}:</span> 
                        <span class="ml-2">${desc.description}</span>
                    `;
                    descriptionsListEl.appendChild(li);
                });
            }
            
            // 6. Host Button
            callVoteBtn.disabled = !isHost || data.gameState === 'cooldown' || data.gameState === 'voting';
        }
        
        function renderVotingView(data) {
            votingReasonEl.textContent = data.votingReason || 'Time is up. Who is the Imposter?';
            votingListEl.innerHTML = '';
            
            const localPlayer = data.roles.find(p => p.id === userId);
            
            if (!localPlayer || localPlayer.isEliminated) {
                votingListEl.innerHTML = '<li class="text-center p-4 text-yellow-400">You are eliminated and cannot vote.</li>';
                skipVoteBtn.disabled = true;
                return;
            }

            const hasVoted = localPlayer.hasVoted;
            skipVoteBtn.disabled = hasVoted;
            
            const playersToVote = data.roles.filter(p => !p.isEliminated);

            playersToVote.forEach(player => {
                const li = document.createElement('li');
                li.className = 'p-2 rounded-md bg-gray-600 flex justify-between items-center';
                
                const playerName = player.name + (player.id === userId ? ' (You)' : '');
                li.textContent = playerName;

                if (player.id !== userId) {
                    const voteBtn = document.createElement('button');
                    voteBtn.className = 'bg-blue-500 hover:bg-blue-400 text-white text-sm py-2 px-4 rounded-md disabled:opacity-50';
                    voteBtn.textContent = hasVoted ? 'Voted' : 'Vote';
                    voteBtn.disabled = hasVoted;
                    voteBtn.addEventListener('click', () => submitVote(player.id, data.id));
                    li.appendChild(voteBtn);
                }
                
                votingListEl.appendChild(li);
            });
        }

        function enterLobbyView(lobbyId) {
             // Clean up any views and show lobby
            document.getElementById('current-lobby-id').textContent = lobbyId;
            resetViews();
            gameLobbyViewEl.classList.remove('hidden');
            updateStatus(`Joined lobby ${lobbyId}. Waiting for players...`);
        }

        function enterGameOverView(data) {
            resetViews();
            gameOverViewEl.classList.remove('hidden');
            
            const winner = data.winner === 'crewmate' ? 'CREWMATES WIN!' : 'IMPOSTER WINS!';
            winMessageEl.textContent = winner;
            winMessageEl.classList.remove('text-green-500', 'text-red-500'); // Clear previous classes
            winMessageEl.classList.add(data.winner === 'crewmate' ? 'text-green-500' : 'text-red-500');

            finalSecretWordEl.textContent = data.secretWord;

            finalRolesListEl.innerHTML = '';
            (data.roles || []).forEach(p => {
                 const li = document.createElement('li');
                 const roleColor = p.role === 'imposter' ? 'text-red-400' : 'text-green-400';
                 const status = p.isEliminated ? ' (Ejected)' : '';
                 li.className = 'p-2 rounded-md bg-gray-600';
                 li.innerHTML = `<span class="font-bold">${p.name}</span> was the <span class="${roleColor}">${p.role.toUpperCase()}</span>${status}`;
                 finalRolesListEl.appendChild(li);
            });
            updateStatus("Game over.");
        }


        // --- EVENT LISTENERS ---

        document.getElementById('create-lobby-btn').addEventListener('click', () => {
             if (userId) {
                 const newLobbyId = generateLobbyId();
                 const lobbyRef = getLobbyDocRef(newLobbyId);
                 
                 const initialLobbyData = {
                    id: newLobbyId,
                    status: 'waiting',
                    players: [{ id: userId, name: `Player_${userId.substring(0, 4)}`, isHost: true }],
                    hostId: userId,
                    maxPlayers: MAX_PLAYERS,
                    createdAt: new Date().toISOString()
                };

                setDoc(lobbyRef, initialLobbyData)
                    .then(() => joinLobby(newLobbyId))
                    .catch(error => displayErrorMessage(`Lobby Creation Error: ${error.message}`));
             }
        });
        
        document.getElementById('join-lobby-btn').addEventListener('click', () => {
            const lobbyId = document.getElementById('join-lobby-id').value.trim().toUpperCase();
            if (lobbyId.length > 0) {
                joinLobby(lobbyId);
            } else {
                displayErrorMessage("Please enter a Lobby ID.");
            }
        });
        
        leaveLobbyBtn.addEventListener('click', () => leaveLobby(false));
        leaveGameBtn.addEventListener('click', () => leaveLobby(true)); 

        document.getElementById('return-to-lobby-btn').addEventListener('click', () => {
             // Reset the document and go back to the main menu
             const lobbyRef = getLobbyDocRef(currentLobbyId);
             if (currentLobbyId && lobbyRef) {
                 // Clear the game state but keep the lobby open
                 updateDoc(lobbyRef, { status: 'waiting', gameState: null, roles: null, secretWord: null, winner: null, currentRound: 0 }).then(() => {
                      leaveLobby(false);
                 }).catch(e => {
                     console.error("Error cleaning up game state:", e);
                     leaveLobby(false);
                 });
             }
        });

        startGameBtn.addEventListener('click', async () => {
            if (!currentLobbyId) return;

            const docSnap = await getDoc(getLobbyDocRef(currentLobbyId));
            if (docSnap.exists()) {
                const players = docSnap.data().players;
                startGameLogic(players, currentLobbyId);
            }
        });
        
        submitDescriptionBtn.addEventListener('click', () => {
            submitDescription(descriptionInputEl.value, currentLobbyId);
        });

        skipVoteBtn.addEventListener('click', () => {
             submitVote(null, currentLobbyId); // null vote means skip
        });
        
        callVoteBtn.addEventListener('click', () => {
             callEmergencyVote(currentLobbyId); 
        });

        // --- FIREBASE INITIALIZATION & AUTHENTICATION (MOVED TO BOTTOM FOR CLARITY) ---

        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig); 
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth); 
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        updateStatus("Signed in anonymously. Ready to play.");
                        currentUserIdEl.textContent = userId;
                        resetViews();
                    } else {
                        updateStatus("Authentication failed. Critical failure.");
                    }
                });

            } catch (error) {
                updateStatus(`Firebase Initialization Failed: ${error.message}`);
                console.error("Firebase Initialization Failed:", error);
            }
        }
        
        async function joinLobby(lobbyId) {
            if (!userId || !lobbyId) return;

            const lobbyRef = getLobbyDocRef(lobbyId);

            try {
                const docSnap = await getDoc(lobbyRef);
                
                if (!docSnap.exists()) {
                    displayErrorMessage(`Lobby ${lobbyId} not found.`);
                    return;
                }

                const lobbyData = docSnap.data();
                
                if (lobbyData.status === 'in_game') {
                    // Allow rejoining active game
                    const playerEntry = lobbyData.roles.find(p => p.id === userId);
                    if (playerEntry) {
                         currentLobbyId = lobbyId;
                         subscribeToLobby(lobbyId); // Go straight to game view
                         return;
                    }
                    displayErrorMessage("Game is already in progress and you are not a participant.");
                    return;
                } else if (lobbyData.status !== 'waiting') {
                    displayErrorMessage(`Lobby ${lobbyId} is in an unknown state: ${lobbyData.status}.`);
                    return;
                }
                
                if (lobbyData.players.length >= MAX_PLAYERS) {
                    displayErrorMessage(`Lobby ${lobbyId} is full! Max: ${MAX_PLAYERS}`);
                    return;
                }

                if (!lobbyData.players.some(p => p.id === userId)) {
                    const playerName = `Player_${userId.substring(0, 4)}`;
                    const updatedPlayers = [...lobbyData.players, { id: userId, name: playerName, isHost: false }];
                    
                    await updateDoc(lobbyRef, { players: updatedPlayers });
                }

                currentLobbyId = lobbyId;
                subscribeToLobby(lobbyId); // Now use subscribe to start the listener
            } catch (error) {
                displayErrorMessage(`Error joining lobby: ${error.message}`);
                console.error("Error joining lobby:", error);
            }
        }

        async function leaveLobby(isGameQuit = false) {
            if (!currentLobbyId || !userId) return;

            if (hostTimerInterval) clearInterval(hostTimerInterval);
            const lobbyRef = getLobbyDocRef(currentLobbyId);

            try {
                const docSnap = await getDoc(lobbyRef);
                if (docSnap.exists()) {
                    const lobbyData = docSnap.data();
                    
                    let playersKey = lobbyData.status === 'in_game' ? 'roles' : 'players';
                    
                    const updatedPlayers = (lobbyData[playersKey] || []).filter(p => p.id !== userId);
                    
                    if (updatedPlayers.length > 0) {
                        const isHost = lobbyData.hostId === userId;
                        let updateData = {};
                        if (isHost) {
                            const nextHost = updatedPlayers.find(p => !p.isEliminated) || updatedPlayers[0];
                            if (nextHost) {
                                updateData.hostId = nextHost.id;
                                updateData[playersKey] = updatedPlayers.map(p => ({
                                    ...p,
                                    isHost: p.id === nextHost.id
                                }));
                            } else {
                                updateData[playersKey] = updatedPlayers; 
                            }
                        } else {
                             updateData[playersKey] = updatedPlayers;
                        }
                        
                        await updateDoc(lobbyRef, updateData);
                    } else {
                         // Delete the document if the last player leaves
                        await deleteDoc(lobbyRef);
                    }
                }
            } catch (error) {
                console.error("Error leaving lobby:", error);
            }

            if (unsubscribeLobby) {
                unsubscribeLobby(); 
                unsubscribeLobby = null;
            }
            currentLobbyId = null;
            localPlayerRole = null;
            resetViews();
            updateStatus("Lobby left. Ready to join or create.");
        }


        // --- APPLICATION START ---
        
        window.onload = initializeFirebase;

    </script>
</body>
</html>
