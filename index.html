<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secret Word Imposter Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for a dark, space-themed look */
        body {
            background-color: #1a1a2e; /* Dark purple/blue */
            color: #ffffff;
        }
        .card {
            background-color: #2c2c54; /* Slightly lighter card background */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
        }
        .btn-primary {
            transition: all 0.2s;
            background-color: #ff6b6b; /* Red accent */
            color: #1a1a2e;
            font-weight: bold;
            box-shadow: 0 4px #e55039;
        }
        .btn-primary:hover {
            background-color: #ff8585;
            box-shadow: 0 2px #e55039;
            transform: translateY(2px);
        }
        .btn-secondary {
            transition: all 0.2s;
            background-color: #48dbfb; /* Blue accent */
            color: #1a1a2e;
            font-weight: bold;
            box-shadow: 0 4px #1e90ff;
        }
        .btn-secondary:hover {
            background-color: #6aefff;
            box-shadow: 0 2px #1e90ff;
            transform: translateY(2px);
        }
        /* Mobile optimization for buttons and inputs */
        input[type="text"], .btn {
            height: 52px;
            font-size: 1.1rem;
        }
        .imposter-role { background-color: #e53e3e; }
        .turn-display {
            background-color: #0c4a6e;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: 700;
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen font-sans">
    
    <div id="app" class="w-full max-w-lg">
        
        <!-- Status Display -->
        <div id="status-message" class="text-center p-3 mb-4 rounded-lg text-sm bg-gray-700 text-gray-300">
            STATUS: Initializing Firebase...
        </div>

        <!-- Main Content Area -->
        <div id="content" class="card p-6 rounded-xl space-y-6">
            <h1 class="text-3xl font-extrabold text-center text-[#ff6b6b]">
                <svg class="inline-block w-8 h-8 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                The Secret Word Game
            </h1>

            <!-- Lobby Creation/Joining View -->
            <div id="lobby-view" class="space-y-4">
                <button id="create-lobby-btn" class="w-full btn-primary btn rounded-lg">
                    Create New Lobby
                </button>

                <div class="flex items-center space-x-2 text-gray-400">
                    <hr class="flex-grow border-gray-600">
                    <span class="text-sm">OR JOIN</span>
                    <hr class="flex-grow border-gray-600">
                </div>

                <div class="flex space-x-2">
                    <input type="text" id="join-lobby-id" placeholder="Enter Lobby ID" class="flex-grow p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 focus:ring-[#48dbfb] outline-none">
                    <button id="join-lobby-btn" class="btn-secondary btn px-6 rounded-lg">
                        Join
                    </button>
                </div>
            </div>

            <!-- Game Lobby View -->
            <div id="game-lobby-view" class="hidden space-y-4">
                <h2 class="text-2xl font-bold text-center">Lobby: <span id="current-lobby-id" class="text-[#48dbfb]"></span></h2>
                <p class="text-sm text-gray-400 text-center">Share this ID with friends!</p>
                <div class="text-sm text-center text-gray-500">
                    Your Player ID: <span id="current-user-id" class="break-all font-mono text-xs"></span>
                </div>
                
                <!-- Player Count Display - Now more prominent -->
                <div class="text-2xl font-extrabold text-center mt-4 p-2 bg-gray-700 rounded-lg border-b-4 border-[#ff6b6b]">
                     Active Players: <span id="player-count" class="text-[#48dbfb]">0</span>
                </div>

                <h3 class="text-lg font-semibold mt-4">Players in Lobby:</h3>
                <ul id="players-list" class="space-y-2 p-3 rounded-lg bg-gray-700 h-40 overflow-y-auto">
                    <!-- Player names go here -->
                </ul>

                <button id="start-game-btn" class="w-full btn-primary btn rounded-lg mt-4 disabled:opacity-50" disabled>
                    Start Game (Need 3+ Players)
                </button>
                <button id="leave-lobby-btn" class="w-full btn-secondary btn rounded-lg mt-2">
                    Leave Lobby
                </button>
            </div>

            <!-- Active Game View (Word Deduction) -->
            <div id="game-active-view" class="hidden space-y-6">
                <div id="role-display" class="text-center p-4 rounded-xl font-bold text-xl transition-all duration-500 bg-gray-800">
                    Your Role: <span id="player-role-text" class="text-yellow-400">Loading...</span>
                </div>
                
                <div class="p-4 rounded-xl bg-gray-800 border-2 border-[#48dbfb]">
                    <p class="text-lg font-bold text-center">SECRET WORD:</p>
                    <p id="secret-word-display" class="text-4xl font-extrabold text-center text-[#ff6b6b] mt-1">???</p>
                </div>

                <div id="game-info" class="p-3 rounded-lg bg-gray-700 flex justify-between items-center">
                    <div class="space-y-1">
                        <p class="text-lg font-bold">Round <span id="current-round-number">1</span> / <span id="total-rounds-number">4</span></p>
                        <p class="text-sm text-gray-400 font-bold" id="game-phase-label">Status: Active</p>
                    </div>
                    <div class="text-right">
                         <!-- This now shows TURN status, not a countdown -->
                         <p class="text-xl font-extrabold text-[#48dbfb]" id="round-timer">Submission Based</p>
                         <button id="call-vote-btn" class="text-sm text-yellow-400 hover:text-yellow-300 disabled:opacity-50" disabled>Call Emergency Vote</button>
                    </div>
                </div>
                
                <!-- Description Input and Submission -->
                <div id="description-area" class="space-y-2">
                    <label for="description-input" class="block font-semibold">Your Description for this Round:</label>
                    <div class="flex space-x-2">
                        <input type="text" id="description-input" maxlength="50" placeholder="Describe the word..." class="flex-grow p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 focus:ring-[#48dbfb] outline-none disabled:opacity-50">
                        <button id="submit-description-btn" class="btn-primary btn px-6 rounded-lg disabled:opacity-50">Submit</button>
                    </div>
                    <p id="submission-status" class="text-sm text-green-400 hidden">Submitted!</p>
                </div>

                <!-- Previous Descriptions Display -->
                <h3 class="text-lg font-semibold mt-4">Round Descriptions:</h3>
                <ul id="descriptions-list" class="space-y-3 p-3 rounded-lg bg-gray-700 max-h-60 overflow-y-auto">
                    <li class="text-gray-400 text-center">Descriptions will appear here after submission.</li>
                </ul>
                
                <button id="leave-game-btn" class="w-full btn-secondary btn rounded-lg mt-4">
                    Quit Game
                </button>
            </div>
            
            <!-- Voting View -->
            <div id="voting-view" class="hidden space-y-6">
                <h2 class="text-3xl font-bold text-center text-[#ff6b6b]">VOTING PHASE!</h2>
                <p class="text-center text-lg text-gray-300" id="voting-reason">Time is up. Who is the Imposter?</p>
                
                <div class="turn-display mx-auto text-center" id="voting-timer-display">
                    Time Remaining: 10s
                </div>

                <h3 class="text-xl font-semibold mt-4">Vote to eject:</h3>
                <ul id="voting-list" class="space-y-2 p-3 rounded-lg bg-gray-700 max-h-60 overflow-y-auto">
                    <!-- Voting buttons go here -->
                </ul>
                
                <button id="skip-vote-btn" class="w-full bg-gray-500 hover:bg-gray-400 text-white font-bold py-3 px-4 rounded-lg">
                    Skip Vote
                </button>
            </div>

            <!-- Game Over View -->
            <div id="game-over-view" class="hidden space-y-6">
                <h2 class="text-4xl font-extrabold text-center" id="win-message"></h2>
                <p class="text-center text-xl text-gray-300">The Secret Word was: <span id="final-secret-word" class="text-yellow-400 font-bold"></span></p>
                <p class="text-center text-xl text-gray-300">Roles were:</p>
                <ul id="final-roles-list" class="space-y-2 p-3 rounded-lg bg-gray-700">
                    <!-- Final roles displayed here -->
                </ul>
                <button id="return-to-lobby-btn" class="w-full btn-secondary btn rounded-lg mt-4">
                    Return to Lobby
                </button>
            </div>

        </div>
    </div>
    
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, deleteDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIGURATION SETUP (ROBUST AGAINST EXTERNAL DEPLOYMENT) ---
        
        const localFirebaseConfig = {
            apiKey: "AIzaSyCWEJOsUXTjdkYPUF_Iz6j5siieTJw5Rs0",
            authDomain: "impostergame-dev.firebaseapp.com",
            projectId: "impostergame-dev",
            storageBucket: "impostergame-dev.firebasestorage.app",
            messagingSenderId: "619697208061",
            appId: "1:619697208061:web:0a62ff8e6a9a701140dc94",
            measurementId: "G-C1HWQ86HV3"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : localFirebaseConfig.projectId;
        let firebaseConfig;
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
             try {
                firebaseConfig = JSON.parse(__firebase_config);
             } catch (e) {
                console.error("Failed to parse __firebase_config. Falling back to local config.", e);
                firebaseConfig = localFirebaseConfig;
             }
        } else {
             firebaseConfig = localFirebaseConfig;
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        setLogLevel('Debug');
        let app, db, auth;
        let userId = null;
        let currentLobbyId = null;
        let unsubscribeLobby = null;
        let localPlayerRole = null;
        let hostTimerInterval = null; // Timer for the host to manage cooldowns/voting

        // --- GAME CONSTANTS ---
        const MAX_PLAYERS = 100; 
        const MIN_PLAYERS_TO_START = 3; 
        const IMPOSTER_COUNT = 1; 
        const COOLDOWN_DURATION_SECONDS = 5; 
        const VOTING_DURATION_SECONDS = 10; // New constant for voting time
        const TOTAL_ROUNDS = 4;
        
        // Simple word list for the crewmates
        const WORD_LIST = ["SPACESHIP", "GALAXY", "PIZZA", "OCEAN", "MOUNTAIN", "KEYBOARD", "BOOK", "FARMER", "TELEVISION", "COMPUTER", "PROGRAMMER", "ELEPHANT", "GIRAFFE", "TIGER", "PENGUIN", "WHALE", "SHARK", "DOLPHIN", "BUTTERFLY", "DRAGONFLY", "SUNFLOWER", "RAINBOW", "THUNDERSTORM", "LIGHTNING", "WATERFALL", "DESERT", "VOLCANO", "JUNGLE", "FOREST", "RIVER", "BEACH", "ISLAND", "VOLLEYBALL", "BASKETBALL", "FOOTBALL", "SOCCER", "HOCKEY", "CHESS", "MONOPOLY", "JIGSAW", "PUZZLE", "GUITAR", "PIANO", "VIOLIN", "DRUMS", "SAXOPHONE", "FLUTE", "MICROPHONE", "HEADPHONES", "SPEAKER", "MONITOR", "MOUSE", "LAPTOP", "TABLET", "SMARTPHONE", "PRINTER", "SCANNER", "CAMERA", "BICYCLE", "CAROUSEL", "ROLLERCOASTER", "FERRISWHEEL", "BRIDGE", "TUNNEL", "HIGHWAY", "AIRPORT", "SUBMARINE", "HELICOPTER", "SATELLITE", "COMET", "METEOR", "ASTEROID", "STAR", "PLANET", "MOON", "SUN", "UNIVERSE", "COFFEE", "ORANGE", "BANANA", "STRAWBERRY", "CHOCOLATE", "VANILLA", "BREAD", "CHEESE", "PASTA", "BURRITO", "TACO", "SUSHI", "NOODLES", "PANCAKE", "WAFFLE", "CEREAL", "TOAST", "SANDWICH", "HOTDOG", "BURGER", "FRENCHFRIES", "BACON", "EGG", "COWBOY", "PIRATE", "NINJA", "SAMURAI", "WIZARD", "FAIRY", "MERMAID", "DRAGON", "UNICORN", "PHOENIX", "GHOST", "ZOMBIE", "VAMPIRE", "WEREWOLF", "MUMMY", "FRANKENSTEIN", "ROBOT", "SUPERHERO", "VILLAIN"];

        // --- UI ELEMENT REFERENCES ---

        const statusEl = document.getElementById('status-message');
        const lobbyViewEl = document.getElementById('lobby-view');
        const gameLobbyViewEl = document.getElementById('game-lobby-view');
        const gameActiveViewEl = document.getElementById('game-active-view');
        const votingViewEl = document.getElementById('voting-view');
        const gameOverViewEl = document.getElementById('game-over-view');

        const currentUserIdEl = document.getElementById('current-user-id');
        const playersListEl = document.getElementById('players-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        
        const playerCountEl = document.getElementById('player-count'); 
        
        const playerRoleTextEl = document.getElementById('player-role-text');
        const secretWordDisplayEl = document.getElementById('secret-word-display');
        const currentRoundNumberEl = document.getElementById('current-round-number');
        const totalRoundsNumberEl = document.getElementById('total-rounds-number');
        const gamePhaseLabelEl = document.getElementById('game-phase-label');
        const roundTimerEl = document.getElementById('round-timer');
        const callVoteBtn = document.getElementById('call-vote-btn');
        const descriptionInputEl = document.getElementById('description-input');
        const submitDescriptionBtn = document.getElementById('submit-description-btn');
        const submissionStatusEl = document.getElementById('submission-status');
        const descriptionsListEl = document.getElementById('descriptions-list');

        const votingReasonEl = document.getElementById('voting-reason');
        const votingListEl = document.getElementById('voting-list');
        const votingTimerDisplayEl = document.getElementById('voting-timer-display');
        const skipVoteBtn = document.getElementById('skip-vote-btn');
        
        const winMessageEl = document.getElementById('win-message');
        const finalSecretWordEl = document.getElementById('final-secret-word');
        const finalRolesListEl = document.getElementById('final-roles-list');

        // --- UTILITIES ---

        function updateStatus(message) {
            statusEl.textContent = `STATUS: ${message}`;
        }
        
        function displayErrorMessage(message) {
             statusEl.textContent = `ERROR: ${message}`;
             statusEl.classList.add('bg-red-700', 'text-red-200');
             setTimeout(() => {
                 statusEl.classList.remove('bg-red-700', 'text-red-200');
                 statusEl.textContent = '';
             }, 5000);
        }

        function resetViews() {
            lobbyViewEl.classList.remove('hidden');
            gameLobbyViewEl.classList.add('hidden');
            gameActiveViewEl.classList.add('hidden');
            votingViewEl.classList.add('hidden');
            gameOverViewEl.classList.add('hidden');
        }

        function getLobbyDocRef(id) {
            return doc(db, `artifacts/${appId}/public/data/lobbies`, id);
        }

        function generateLobbyId() {
            return Math.random().toString(36).substring(2, 6).toUpperCase();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // --- GAME FLOW CORE FUNCTIONS ---
        
        /**
         * Host-only function to force the end of the voting phase regardless of vote completion.
         */
        async function resolveVotingPhase(data) {
             // Host runs the check to tally and transition state
             await checkVoteResult(data); 
        }

        /**
         * Host-only function to manage the game progression based on time (Cooldown and Voting).
         */
        async function runHostTimer(lobbyId) {
            if (hostTimerInterval) clearInterval(hostTimerInterval);
            
            hostTimerInterval = setInterval(async () => {
                const lobbyRef = getLobbyDocRef(lobbyId);
                let docSnap = null;
                try {
                    docSnap = await getDoc(lobbyRef);
                } catch (e) {
                    console.error("Host timer failed to fetch doc:", e);
                    clearInterval(hostTimerInterval);
                    return;
                }

                if (!docSnap.exists() || docSnap.data().status !== 'in_game') {
                    clearInterval(hostTimerInterval);
                    return;
                }
                
                const data = docSnap.data();
                const now = Date.now();
                const timeRemaining = data.roundEndTime ? data.roundEndTime - now : 0;
                
                // Update timer UI for voting
                if (data.gameState === 'voting') {
                    const seconds = Math.floor(timeRemaining / 1000);
                    votingTimerDisplayEl.textContent = timeRemaining > 0 ? `Time Remaining: ${seconds}s` : 'Time is up!';
                }


                if (timeRemaining <= 0) {
                    // Time is up, advance state
                    let updateData = {};
                    
                    if (data.gameState === 'cooldown') {
                        // Move to Next Round Active, reset descriptions, and set the first speaker
                        const nextRound = data.currentRound; // Round already incremented in submitDescription
                        const firstSpeakerId = data.turnOrder[0];

                        if (nextRound <= data.totalRounds) {
                             updateData = {
                                gameState: 'round_active',
                                currentSpeakerId: firstSpeakerId,
                                descriptions: {}, 
                                roundEndTime: null // Submission based, no timer needed
                            };
                            updateStatus(`Host: Starting Round ${nextRound}. Turn: ${data.roles.find(p => p.id === firstSpeakerId)?.name}`);
                        } 
                        
                    } else if (data.gameState === 'voting') {
                        // Voting time is over (10 seconds) - force vote resolution
                        clearInterval(hostTimerInterval);
                        await resolveVotingPhase(data); 
                        return;
                    } else {
                        // Game state is 'finished', stop host timer
                        clearInterval(hostTimerInterval);
                        return;
                    }

                    if (Object.keys(updateData).length > 0) {
                        await updateDoc(lobbyRef, updateData);
                    }
                }
            }, 1000);
        }

        async function startGameLogic(players, lobbyId) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            
            // 1. Assign Roles
            let playerIds = players.map(p => p.id);
            shuffleArray(playerIds);
            const imposterId = playerIds[0];

            const playerRoles = players.map(player => ({
                ...player,
                role: player.id === imposterId ? 'imposter' : 'crewmate',
                isEliminated: false,
                hasVoted: false,
                vote: null,
                name: player.name || `Player_${player.id.substring(0, 4)}` 
            }));
            
            // 2. Select Secret Word
            shuffleArray(WORD_LIST);
            const secretWord = WORD_LIST[0];

            // 3. Generate Turn Order and ensure Imposter is NOT first
            let turnOrder = playerRoles.filter(p => !p.isEliminated).map(p => p.id);
            shuffleArray(turnOrder); 
            
            let imposterIndex = turnOrder.indexOf(imposterId);
            if (imposterIndex === 0 && turnOrder.length > 1) {
                // Swap the imposter (at index 0) with a player at a random position > 0
                const swapIndex = Math.floor(Math.random() * (turnOrder.length - 1)) + 1;
                [turnOrder[0], turnOrder[swapIndex]] = [turnOrder[swapIndex], turnOrder[0]];
            } else if (imposterIndex === 0 && turnOrder.length === 1) {
                // Should not happen as min players is 3, but prevents crash
                 console.warn("Imposter is the only player. Game will likely fail.");
            }

            const currentSpeakerId = turnOrder[0];


            // 4. Set Initial Game State
            const gameData = {
                id: lobbyId,
                status: 'in_game',
                gameState: 'round_active',
                secretWord: secretWord,
                roles: playerRoles,
                hostId: userId,
                currentRound: 1,
                totalRounds: TOTAL_ROUNDS,
                descriptions: {}, 
                votes: {}, 
                // NEW TURN-BASED FIELDS
                turnOrder: turnOrder,
                currentSpeakerId: currentSpeakerId,
                roundEndTime: null // Submission based, no timer needed
            };
            
            try {
                await updateDoc(lobbyRef, gameData);
                updateStatus("Game started successfully!");
            } catch (error) {
                displayErrorMessage(`Failed to start game: ${error.message}`);
                console.error("Game Start Error:", error);
            }
        }

        // --- GAME ACTIONS ---

        async function submitDescription(description, lobbyId) {
            if (!description.trim()) {
                displayErrorMessage("Description cannot be empty.");
                return;
            }
            const lobbyRef = getLobbyDocRef(lobbyId);
            const docSnap = await getDoc(lobbyRef);
            const data = docSnap.data();

            if (data.currentSpeakerId !== userId) {
                 displayErrorMessage("It is not your turn to submit a description.");
                 return;
            }
            
            const localPlayer = data.roles.find(p => p.id === userId);

            if (!localPlayer || localPlayer.isEliminated) {
                displayErrorMessage("You are eliminated and cannot submit descriptions.");
                return;
            }
            
            if (data.gameState !== 'round_active') {
                displayErrorMessage("Cannot submit description outside of an active round.");
                return;
            }

            try {
                // 1. Update the descriptions map with the player's submission
                const newDescriptions = { 
                    ...data.descriptions, 
                    [userId]: description.trim() 
                };
                
                // 2. --- ADVANCE TURN LOGIC (Executed by the submitting player) ---
                const currentSpeakerIndex = data.turnOrder.indexOf(userId);
                const nextSpeakerIndex = (currentSpeakerIndex + 1) % data.turnOrder.length;
                const nextSpeakerId = data.turnOrder[nextSpeakerIndex];

                let updateData = { descriptions: newDescriptions };

                if (nextSpeakerIndex === 0) {
                    // Cycle complete - check if we advance round or go to voting
                    const nextRound = data.currentRound + 1;
                    
                    if (nextRound <= data.totalRounds) {
                        // Move to Cooldown
                        updateData.gameState = 'cooldown';
                        updateData.currentRound = nextRound;
                        updateData.roundEndTime = Date.now() + COOLDOWN_DURATION_SECONDS * 1000;
                        updateData.currentSpeakerId = nextSpeakerId; // Set speaker for next active round
                        updateData.descriptions = {}; // Clear descriptions for the start of the next round
                        updateStatus(`Round ${data.currentRound} complete. Cooldown started.`);
                    } else {
                        // All rounds complete - move to Final Voting
                        updateData.gameState = 'voting';
                        updateData.votingReason = 'Final vote: All description rounds complete.';
                        updateData.roundEndTime = Date.now() + VOTING_DURATION_SECONDS * 1000; // 10 seconds for voting
                        updateData.currentSpeakerId = null;
                        updateStatus("All rounds complete. Starting final vote.");
                    }

                } else {
                    // Move to next player in the turn order
                    updateData.currentSpeakerId = nextSpeakerId;
                    updateStatus(`Turn advanced to ${data.roles.find(p => p.id === nextSpeakerId)?.name}`);
                }

                await updateDoc(lobbyRef, updateData);
                
                // UI updates for the submitting player
                submissionStatusEl.textContent = 'Submitted!';
                submissionStatusEl.classList.remove('hidden');
                descriptionInputEl.value = ''; // Clear input after submission
                submitDescriptionBtn.disabled = true;
                descriptionInputEl.disabled = true;

            } catch (error) {
                displayErrorMessage(`Submission error: ${error.message}`);
                console.error("Description Submission Error:", error);
            }
        }
        
        async function submitVote(votedPlayerId, lobbyId) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            const docSnap = await getDoc(lobbyRef);
            const data = docSnap.data();

            const localPlayer = data.roles.find(p => p.id === userId);
            if (!localPlayer || localPlayer.hasVoted || localPlayer.isEliminated || data.gameState !== 'voting') return;

            try {
                // Update the local player's vote state
                const updatedRoles = data.roles.map(p => {
                    if (p.id === userId) {
                        return { ...p, hasVoted: true, vote: votedPlayerId };
                    }
                    return p;
                });

                // The host will resolve the vote when the timer runs out, 
                // but we keep the voteCount to handle early resolution if all votes are cast.
                const newVoteCount = updatedRoles.filter(p => p.hasVoted).length;
                
                await updateDoc(lobbyRef, {
                    roles: updatedRoles,
                    voteCount: newVoteCount 
                });
                updateStatus(`Voted. Waiting for vote resolution.`);

            } catch (error) {
                displayErrorMessage(`Voting error: ${error.message}`);
            }
        }

        async function checkVoteResult(data) {
            const lobbyRef = getLobbyDocRef(data.id);
            const activePlayers = data.roles.filter(p => !p.isEliminated);
            
            // Tally votes
            const tallies = {};
            data.roles.forEach(p => {
                if (p.vote) { // Null vote is skip, not tallied
                    tallies[p.vote] = (tallies[p.vote] || 0) + 1;
                }
            });

            // Find the maximum number of votes
            let maxVotes = 0;
            let ejectedId = null;
            let tied = false;

            for (const [id, count] of Object.entries(tallies)) {
                if (count > maxVotes) {
                    maxVotes = count;
                    ejectedId = id;
                    tied = false;
                } else if (count === maxVotes && maxVotes > 0) {
                    tied = true;
                }
            }
            
            let ejectedPlayer = null;
            let updateData = {}; 

            if (ejectedId && !tied) {
                // Eject the player with the most votes (no tie)
                ejectedPlayer = data.roles.find(p => p.id === ejectedId);
                const updatedRoles = data.roles.map(p => {
                    if (p.id === ejectedId) {
                        return { ...p, isEliminated: true };
                    }
                    return p;
                });
                
                const imposterEjected = ejectedPlayer.role === 'imposter';

                updateData = {
                    roles: updatedRoles,
                    status: 'finished', // Game ends immediately on successful Imposter ejection
                    gameState: 'finished',
                    winner: imposterEjected ? 'crewmate' : null,
                };
                
            } else {
                // Tie or skip vote - game continues
                updateData = {
                    gameState: 'cooldown', // Go to cooldown after a skipped or tied vote
                    currentRound: data.currentRound, 
                    roundEndTime: Date.now() + COOLDOWN_DURATION_SECONDS * 1000,
                };
            }
            
            // Reset voting state and apply elimination (if any)
            updateData.roles = updateData.roles || data.roles;
            updateData.roles = updateData.roles.map(p => ({
                ...p,
                hasVoted: false,
                vote: null,
            }));
            
            // Only host updates the doc after processing votes
            if (data.hostId === userId) {
                 await updateDoc(lobbyRef, updateData);
            }
        }
        
        // Removed callEmergencyVote to simplify the turn-based flow for now.
        // It can be added back later if desired.

        async function endGame(lobbyId, winner, roles) {
            const lobbyRef = getLobbyDocRef(lobbyId);
            if (hostTimerInterval) clearInterval(hostTimerInterval);

            // Only host updates the final state
            if (roles.find(p => p.id === userId)?.role === 'imposter' || data.hostId === userId) {
                 await updateDoc(lobbyRef, {
                    status: 'finished',
                    gameState: 'finished',
                    winner: winner,
                    roles: roles 
                });
            }
        }


        // --- REAL-TIME LOBBY LISTENER (onSnapshot) ---
        
        function subscribeToLobby(lobbyId) {
            if (unsubscribeLobby) unsubscribeLobby();
            if (hostTimerInterval) clearInterval(hostTimerInterval); 

            const lobbyRef = getLobbyDocRef(lobbyId);
            
            unsubscribeLobby = onSnapshot(lobbyRef, (docSnap) => {
                if (docSnap.exists()) {
                    const lobbyData = docSnap.data();
                    
                    if (lobbyData.status === 'waiting') {
                        enterLobbyView(lobbyId);
                        renderLobbyDetails(lobbyData);
                    } else if (lobbyData.status === 'in_game') {
                        // Start or restart host timer if we are the host and game is active
                        if (lobbyData.hostId === userId && (lobbyData.gameState === 'cooldown' || lobbyData.gameState === 'voting')) {
                             runHostTimer(lobbyId);
                        }
                        renderGameController(lobbyData);
                    } else if (lobbyData.status === 'finished') {
                        enterGameOverView(lobbyData);
                    }
                    
                } else {
                    if (currentLobbyId === lobbyId) {
                        displayErrorMessage("The lobby was closed or deleted.");
                        leaveLobby(); 
                    }
                }
            }, (error) => {
                console.error("Lobby Snapshot Error:", error);
                displayErrorMessage("Lost connection to the lobby.");
                leaveLobby();
            });
        }
        
        // --- RENDER CONTROLLERS ---

        function renderGameController(data) {
            const localPlayer = data.roles.find(p => p.id === userId);
            localPlayerRole = localPlayer ? localPlayer.role : null;
            
            // Check win condition on every update
            const imposter = data.roles.find(p => p.role === 'imposter');
            const activeCrewmates = data.roles.filter(p => p.role === 'crewmate' && !p.isEliminated);

            if (imposter.isEliminated) {
                endGame(data.id, 'crewmate', data.roles);
                return;
            }
            
            // Imposter wins if there are not enough crewmates left
            if (activeCrewmates.length <= IMPOSTER_COUNT) {
                endGame(data.id, 'imposter', data.roles);
                return;
            }
            
            // Imposter wins if all rounds are over and they haven't been caught
            if (data.gameState === 'cooldown' && data.currentRound > TOTAL_ROUNDS) {
                 endGame(data.id, 'imposter', data.roles);
                 return;
            }

            if (data.gameState === 'voting') {
                gameActiveViewEl.classList.add('hidden');
                votingViewEl.classList.remove('hidden');
                renderVotingView(data);
            } else {
                votingViewEl.classList.add('hidden');
                gameActiveViewEl.classList.remove('hidden');
                renderActiveGameView(data);
            }
        }
        
        function renderLobbyDetails(lobbyData) {
            const players = lobbyData.players || [];
            playersListEl.innerHTML = '';
            
            playerCountEl.textContent = players.length; 

            const isHost = lobbyData.hostId === userId;
            startGameBtn.disabled = !isHost || players.length < MIN_PLAYERS_TO_START;
            
            if (isHost) {
                startGameBtn.textContent = players.length < MIN_PLAYERS_TO_START 
                    ? `Need ${MIN_PLAYERS_TO_START - players.length} more players to start`
                    : 'START GAME';
            } else {
                startGameBtn.textContent = "Waiting for Host to Start...";
            }

            players.forEach(player => {
                const li = document.createElement('li');
                let name = player.name;
                if (player.id === userId) {
                    name += " (You)";
                }
                if (player.id === lobbyData.hostId) {
                    name += " âœ¨Host";
                }
                
                li.className = 'p-2 rounded-md bg-gray-600 flex justify-between items-center';
                li.textContent = name;
                playersListEl.appendChild(li);
            });
        }
        
        function renderActiveGameView(data) {
            const localPlayer = data.roles.find(p => p.id === userId);
            const isEliminated = localPlayer?.isEliminated || false;
            const isHost = data.hostId === userId;
            
            // 1. Role and Word Display
            playerRoleTextEl.textContent = localPlayerRole === 'imposter' ? 'IMPOSTER' : 'CREWMATE';
            playerRoleTextEl.classList.toggle('imposter-role', localPlayerRole === 'imposter');
            playerRoleTextEl.classList.toggle('text-yellow-400', localPlayerRole !== 'imposter');

            const wordToDisplay = localPlayerRole === 'crewmate' ? data.secretWord : '???';
            secretWordDisplayEl.textContent = wordToDisplay;

            // 2. Round Info
            currentRoundNumberEl.textContent = data.currentRound;
            totalRoundsNumberEl.textContent = data.totalRounds;
            
            const currentSpeaker = data.roles.find(p => p.id === data.currentSpeakerId)?.name || 'Unknown';
            const isMyTurn = data.currentSpeakerId === userId;
            
            roundTimerEl.textContent = data.gameState === 'cooldown' ? 'COOLDOWN' : 'Submission Based'; 
            
            // Update the game phase label to show whose turn it is
            gamePhaseLabelEl.innerHTML = data.gameState === 'cooldown' 
                ? 'Status: COOLDOWN' 
                : isMyTurn 
                    ? '<span class="text-green-400 font-extrabold">YOUR TURN!</span>'
                    : `Turn: <span class="text-[#48dbfb] font-extrabold">${currentSpeaker}</span>`;


            // 3. Submission Area
            const submitted = !!data.descriptions[userId];
            const isActive = data.gameState === 'round_active';
            
            // Only enabled if it's the player's turn, game is active, and they aren't eliminated.
            const isEnabled = isMyTurn && isActive && !isEliminated; 
            
            descriptionInputEl.disabled = !isEnabled;
            submitDescriptionBtn.disabled = !isEnabled || !descriptionInputEl.value.trim();
            
            // Hide/Show submission status only when it's not the player's turn or after they submitted
            submissionStatusEl.classList.toggle('hidden', isMyTurn || !submitted);
            submissionStatusEl.textContent = submitted ? 'Submitted!' : '';
            
            descriptionInputEl.oninput = () => {
                 submitDescriptionBtn.disabled = !isEnabled || !descriptionInputEl.value.trim();
            };

            // 4. Descriptions List
            descriptionsListEl.innerHTML = '';
            const playerNames = data.roles.reduce((acc, p) => { acc[p.id] = p.name; return acc; }, {});

            const submittedDescriptions = Object.entries(data.descriptions).map(([playerId, description]) => ({
                name: playerNames[playerId] || playerId.substring(0, 4),
                description: description,
                isEliminated: data.roles.find(p => p.id === playerId)?.isEliminated,
                isSpeaker: playerId === data.currentSpeakerId
            })).sort((a, b) => a.name.localeCompare(b.name));
            
            if (submittedDescriptions.length === 0 && data.gameState === 'round_active') {
                 descriptionsListEl.innerHTML = '<li class="text-gray-400 text-center">Descriptions will appear here after submission.</li>';
            } else {
                submittedDescriptions.forEach(desc => {
                    const li = document.createElement('li');
                    li.className = `p-3 rounded-lg bg-gray-600 border-l-4 ${desc.isEliminated ? 'border-gray-500 text-gray-500 line-through' : 'border-[#48dbfb]'}`;
                    
                    li.innerHTML = `
                        <span class="font-bold">${desc.name}:</span> 
                        <span class="ml-2">${desc.description}</span>
                    `;
                    descriptionsListEl.appendChild(li);
                });
            }
            
            // 5. Host Button (disabled since turn-based flow makes it complicated, keeping it disabled for now)
            callVoteBtn.disabled = true;
        }
        
        function renderVotingView(data) {
            votingReasonEl.textContent = data.votingReason || 'Time is up. Who is the Imposter?';
            votingListEl.innerHTML = '';
            
            const localPlayer = data.roles.find(p => p.id === userId);
            
            if (!localPlayer || localPlayer.isEliminated) {
                votingListEl.innerHTML = '<li class="text-center p-4 text-yellow-400">You are eliminated and cannot vote.</li>';
                skipVoteBtn.disabled = true;
                return;
            }

            const hasVoted = localPlayer.hasVoted;
            skipVoteBtn.disabled = hasVoted;
            
            const playersToVote = data.roles.filter(p => !p.isEliminated);

            playersToVote.forEach(player => {
                const li = document.createElement('li');
                li.className = 'p-2 rounded-md bg-gray-600 flex justify-between items-center';
                
                const playerName = player.name + (player.id === userId ? ' (You)' : '');
                li.textContent = playerName;

                if (player.id !== userId) {
                    const voteBtn = document.createElement('button');
                    voteBtn.className = 'bg-blue-500 hover:bg-blue-400 text-white text-sm py-2 px-4 rounded-md disabled:opacity-50';
                    voteBtn.textContent = hasVoted ? 'Voted' : 'Vote';
                    voteBtn.disabled = hasVoted;
                    voteBtn.addEventListener('click', () => submitVote(player.id, data.id));
                    li.appendChild(voteBtn);
                }
                
                votingListEl.appendChild(li);
            });
            
            // TIMER UI is updated by the host timer interval
        }

        function enterLobbyView(lobbyId) {
             // Clean up any views and show lobby
            document.getElementById('current-lobby-id').textContent = lobbyId;
            resetViews();
            gameLobbyViewEl.classList.remove('hidden');
            updateStatus(`Joined lobby ${lobbyId}. Waiting for players...`);
        }

        function enterGameOverView(data) {
            resetViews();
            gameOverViewEl.classList.remove('hidden');
            
            const winner = data.winner === 'crewmate' ? 'CREWMATES WIN!' : 'IMPOSTER WINS!';
            winMessageEl.textContent = winner;
            winMessageEl.classList.remove('text-green-500', 'text-red-500'); 
            winMessageEl.classList.add(data.winner === 'crewmate' ? 'text-green-500' : 'text-red-500');

            finalSecretWordEl.textContent = data.secretWord;

            finalRolesListEl.innerHTML = '';
            (data.roles || []).forEach(p => {
                 const li = document.createElement('li');
                 const roleColor = p.role === 'imposter' ? 'text-red-400' : 'text-green-400';
                 const status = p.isEliminated ? ' (Ejected)' : '';
                 li.className = 'p-2 rounded-md bg-gray-600';
                 li.innerHTML = `<span class="font-bold">${p.name}</span> was the <span class="${roleColor}">${p.role.toUpperCase()}</span>${status}`;
                 finalRolesListEl.appendChild(li);
            });
            updateStatus("Game over.");
        }


        // --- EVENT LISTENERS ---

        document.getElementById('create-lobby-btn').addEventListener('click', () => {
             if (userId) {
                 const newLobbyId = generateLobbyId();
                 const lobbyRef = getLobbyDocRef(newLobbyId);
                 
                 const initialLobbyData = {
                    id: newLobbyId,
                    status: 'waiting',
                    players: [{ id: userId, name: `Player_${userId.substring(0, 4)}`, isHost: true }],
                    hostId: userId,
                    maxPlayers: MAX_PLAYERS,
                    createdAt: new Date().toISOString()
                };

                setDoc(lobbyRef, initialLobbyData)
                    .then(() => joinLobby(newLobbyId))
                    .catch(error => displayErrorMessage(`Lobby Creation Error: ${error.message}`));
             }
        });
        
        document.getElementById('join-lobby-btn').addEventListener('click', () => {
            const lobbyId = document.getElementById('join-lobby-id').value.trim().toUpperCase();
            if (lobbyId.length > 0) {
                joinLobby(lobbyId);
            } else {
                displayErrorMessage("Please enter a Lobby ID.");
            }
        });
        
        leaveLobbyBtn.addEventListener('click', () => leaveLobby(false));
        leaveGameBtn.addEventListener('click', () => leaveLobby(true)); 

        document.getElementById('return-to-lobby-btn').addEventListener('click', () => {
             // Reset the document and go back to the main menu
             const lobbyRef = getLobbyDocRef(currentLobbyId);
             if (currentLobbyId && lobbyRef) {
                 // Clear the game state but keep the lobby open
                 updateDoc(lobbyRef, { status: 'waiting', gameState: null, roles: null, secretWord: null, winner: null, currentRound: 0 }).then(() => {
                      leaveLobby(false);
                 }).catch(e => {
                     console.error("Error cleaning up game state:", e);
                     leaveLobby(false);
                 });
             }
        });

        startGameBtn.addEventListener('click', async () => {
            if (!currentLobbyId) return;

            const docSnap = await getDoc(getLobbyDocRef(currentLobbyId));
            if (docSnap.exists()) {
                const players = docSnap.data().players;
                startGameLogic(players, currentLobbyId);
            }
        });
        
        submitDescriptionBtn.addEventListener('click', () => {
            submitDescription(descriptionInputEl.value, currentLobbyId);
        });

        skipVoteBtn.addEventListener('click', () => {
             submitVote(null, currentLobbyId); // null vote means skip
        });
        
        // Removed callVoteBtn listener since the flow is now turn-based and time-based.


        // --- FIREBASE INITIALIZATION & AUTHENTICATION (MOVED TO BOTTOM FOR CLARITY) ---

        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig); 
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth); 
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        updateStatus("Signed in anonymously. Ready to play.");
                        currentUserIdEl.textContent = userId;
                        resetViews();
                    } else {
                        updateStatus("Authentication failed. Critical failure.");
                    }
                });

            } catch (error) {
                updateStatus(`Firebase Initialization Failed: ${error.message}`);
                console.error("Firebase Initialization Failed:", error);
            }
        }
        
        async function joinLobby(lobbyId) {
            if (!userId || !lobbyId) return;

            const lobbyRef = getLobbyDocRef(lobbyId);

            try {
                const docSnap = await getDoc(lobbyRef);
                
                if (!docSnap.exists()) {
                    displayErrorMessage(`Lobby ${lobbyId} not found.`);
                    return;
                }

                const lobbyData = docSnap.data();
                
                if (lobbyData.status === 'in_game') {
                    // Allow rejoining active game
                    const playerEntry = lobbyData.roles.find(p => p.id === userId);
                    if (playerEntry) {
                         currentLobbyId = lobbyId;
                         subscribeToLobby(lobbyId); // Go straight to game view
                         return;
                    }
                    displayErrorMessage("Game is already in progress and you are not a participant.");
                    return;
                } else if (lobbyData.status !== 'waiting') {
                    displayErrorMessage(`Lobby ${lobbyId} is in an unknown state: ${lobbyData.status}.`);
                    return;
                }
                
                if (lobbyData.players.length >= MAX_PLAYERS) {
                    displayErrorMessage(`Lobby ${lobbyId} is full! Max: ${MAX_PLAYERS}`);
                    return;
                }

                if (!lobbyData.players.some(p => p.id === userId)) {
                    const playerName = `Player_${userId.substring(0, 4)}`;
                    const updatedPlayers = [...lobbyData.players, { id: userId, name: playerName, isHost: false }];
                    
                    await updateDoc(lobbyRef, { players: updatedPlayers });
                }

                currentLobbyId = lobbyId;
                subscribeToLobby(lobbyId); // Now use subscribe to start the listener
            } catch (error) {
                displayErrorMessage(`Error joining lobby: ${error.message}`);
                console.error("Error joining lobby:", error);
            }
        }

        async function leaveLobby(isGameQuit = false) {
            if (!currentLobbyId || !userId) return;

            if (hostTimerInterval) clearInterval(hostTimerInterval);
            const lobbyRef = getLobbyDocRef(currentLobbyId);

            try {
                const docSnap = await getDoc(lobbyRef);
                if (docSnap.exists()) {
                    const lobbyData = docSnap.data();
                    
                    let playersKey = lobbyData.status === 'in_game' ? 'roles' : 'players';
                    
                    const updatedPlayers = (lobbyData[playersKey] || []).filter(p => p.id !== userId);
                    
                    if (updatedPlayers.length > 0) {
                        const isHost = lobbyData.hostId === userId;
                        let updateData = {};
                        if (isHost) {
                            const nextHost = updatedPlayers.find(p => !p.isEliminated) || updatedPlayers[0];
                            if (nextHost) {
                                updateData.hostId = nextHost.id;
                                updateData[playersKey] = updatedPlayers.map(p => ({
                                    ...p,
                                    isHost: p.id === nextHost.id
                                }));
                            } else {
                                updateData[playersKey] = updatedPlayers; 
                            }
                        } else {
                             updateData[playersKey] = updatedPlayers;
                        }
                        
                        await updateDoc(lobbyRef, updateData);
                    } else {
                         // Delete the document if the last player leaves
                        await deleteDoc(lobbyRef);
                    }
                }
            } catch (error) {
                console.error("Error leaving lobby:", error);
            }

            if (unsubscribeLobby) {
                unsubscribeLobby(); 
                unsubscribeLobby = null;
            }
            currentLobbyId = null;
            localPlayerRole = null;
            resetViews();
            updateStatus("Lobby left. Ready to join or create.");
        }


        // --- APPLICATION START ---
        
        window.onload = initializeFirebase;
    </script>
</body>
</html>
